#!/bin/bash
# ViperSSH - TUI SSH Connection Manager
# This wrapper script activates the venv and runs viper.py

# Resolve symlinks to get the real script directory
SOURCE="${BASH_SOURCE[0]}"
while [[ -L "$SOURCE" ]]; do
    DIR="$(cd -P "$(dirname "$SOURCE")" && pwd)"
    SOURCE="$(readlink "$SOURCE")"
    [[ "$SOURCE" != /* ]] && SOURCE="$DIR/$SOURCE"
done
SCRIPT_DIR="$(cd -P "$(dirname "$SOURCE")" && pwd)"
VENV_DIR="$SCRIPT_DIR/venv"
MARKER_FILE="$SCRIPT_DIR/.viperssh_initialized"

# Colors
GREEN='\033[1;32m'
CYAN='\033[1;36m'
MAGENTA='\033[1;35m'
RED='\033[1;31m'
YELLOW='\033[1;33m'
DIM='\033[2m'
RESET='\033[0m'

# Detect the system package manager
detect_package_manager() {
    if command -v apt-get &>/dev/null; then
        echo "apt"
    elif command -v dnf &>/dev/null; then
        echo "dnf"
    elif command -v yum &>/dev/null; then
        echo "yum"
    elif command -v pacman &>/dev/null; then
        echo "pacman"
    elif command -v zypper &>/dev/null; then
        echo "zypper"
    elif command -v apk &>/dev/null; then
        echo "apk"
    elif command -v brew &>/dev/null; then
        echo "brew"
    else
        echo "unknown"
    fi
}

# Get installation command for a package
get_install_command() {
    local pkg_manager="$1"
    local package="$2"

    case "$pkg_manager" in
        apt)     echo "sudo apt install -y $package" ;;
        dnf)     echo "sudo dnf install -y $package" ;;
        yum)     echo "sudo yum install -y $package" ;;
        pacman)  echo "sudo pacman -S --noconfirm $package" ;;
        zypper)  echo "sudo zypper install -y $package" ;;
        apk)     echo "sudo apk add $package" ;;
        brew)    echo "brew install $package" ;;
        *)       echo "# Install '$package' using your package manager" ;;
    esac
}

# Get distro-specific package name
get_package_name() {
    local pkg_manager="$1"
    local generic_name="$2"

    case "$generic_name" in
        python3)
            case "$pkg_manager" in
                pacman) echo "python" ;;
                *)      echo "python3" ;;
            esac
            ;;
        ssh)
            case "$pkg_manager" in
                apt)    echo "openssh-client" ;;
                pacman) echo "openssh" ;;
                *)      echo "openssh-clients" ;;
            esac
            ;;
        *)
            echo "$generic_name"
            ;;
    esac
}

# Check system dependencies
check_dependencies() {
    local missing_required=()
    local missing_optional=()
    local pkg_manager
    pkg_manager=$(detect_package_manager)

    # Required dependencies
    local required_deps=("python3" "ssh")
    # Optional dependencies
    local optional_deps=("expect")

    # Check required dependencies
    for dep in "${required_deps[@]}"; do
        if ! command -v "$dep" &>/dev/null; then
            missing_required+=("$dep")
        fi
    done

    # Check optional dependencies
    for dep in "${optional_deps[@]}"; do
        if ! command -v "$dep" &>/dev/null; then
            missing_optional+=("$dep")
        fi
    done

    # Report missing required dependencies (fatal)
    if [[ ${#missing_required[@]} -gt 0 ]]; then
        echo -e "\n${RED}ERROR: Missing required dependencies${RESET}\n"
        for dep in "${missing_required[@]}"; do
            local pkg_name
            pkg_name=$(get_package_name "$pkg_manager" "$dep")
            local install_cmd
            install_cmd=$(get_install_command "$pkg_manager" "$pkg_name")
            echo -e "  ${RED}[x]${RESET} ${dep} - required"
            echo -e "      ${DIM}Install: ${install_cmd}${RESET}"
        done
        echo ""
        exit 1
    fi

    # Handle missing optional dependencies - offer to install
    if [[ ${#missing_optional[@]} -gt 0 ]]; then
        echo -e "\n${YELLOW}Missing recommended packages:${RESET}\n"
        local install_cmds=()
        for dep in "${missing_optional[@]}"; do
            local pkg_name
            pkg_name=$(get_package_name "$pkg_manager" "$dep")
            local install_cmd
            install_cmd=$(get_install_command "$pkg_manager" "$pkg_name")
            echo -e "  ${YELLOW}•${RESET} ${dep} ${DIM}(enables password caching)${RESET}"
            install_cmds+=("$install_cmd")
        done
        echo ""
        read -p "   Install now? [Y/n]: " response
        if [[ "$response" != "n" && "$response" != "N" ]]; then
            for cmd in "${install_cmds[@]}"; do
                echo -e "\n${CYAN}>> Running: ${cmd}${RESET}\n"
                eval "$cmd"
            done
            # Verify installation
            local still_missing=0
            for dep in "${missing_optional[@]}"; do
                if ! command -v "$dep" &>/dev/null; then
                    still_missing=1
                fi
            done
            if [[ $still_missing -eq 0 ]]; then
                echo -e "\n${GREEN}>> All packages installed successfully!${RESET}\n"
            else
                echo -e "\n${YELLOW}>> Some packages may not have installed correctly${RESET}\n"
            fi
        fi
        return 0  # Interaction occurred
    fi
    return 1  # No missing deps
}

# Run command with sudo if directory is not writable
run_cmd() {
    local target_dir="$1"
    shift
    if [[ -w "$target_dir" ]]; then
        "$@"
    else
        sudo "$@"
    fi
}

# Create and verify symlink
create_symlink() {
    local target_dir="$1"
    local link_name="$2"
    local link_path="$target_dir/$link_name"

    if [[ ! -w "$target_dir" ]]; then
        echo -e "${MAGENTA}   Requires sudo - you may be prompted for your password${RESET}"
    fi

    # Handle existing path
    if [[ -e "$link_path" ]] || [[ -L "$link_path" ]]; then
        if [[ -d "$link_path" ]] && [[ ! -L "$link_path" ]]; then
            echo -e "${MAGENTA}>> $link_path is a directory, cannot overwrite${RESET}"
            return 1
        fi

        echo -e "${MAGENTA}>> $link_path already exists${RESET}"
        read -p "   Overwrite? [y/N]: " overwrite
        [[ "$overwrite" != "y" && "$overwrite" != "Y" ]] && return 1
        run_cmd "$target_dir" rm -f "$link_path"
    fi

    # Create and verify symlink
    if run_cmd "$target_dir" ln -s "$SCRIPT_DIR/viperssh" "$link_path" && [[ -L "$link_path" ]]; then
        echo -e "${GREEN}>> Symlink created: ${CYAN}$link_path${RESET}"
        echo -e "${DIM}>> You can now run '${link_name}' from anywhere${RESET}\n"
        return 0
    fi

    echo -e "${MAGENTA}>> Failed to create symlink${RESET}"
    return 1
}

# Check if directory is in PATH
in_path() {
    [[ ":$PATH:" == *":$1:"* ]]
}

# First-time setup
first_time_setup() {
    echo ""
    echo -e "${GREEN}╦  ╦╦╔═╗╔═╗╦═╗${CYAN}╔═╗╔═╗╦ ╦${RESET}"
    echo -e "${GREEN}╚╗╔╝║╠═╝║╣ ╠╦╝${CYAN}╚═╗╚═╗╠═╣${RESET}"
    echo -e "${GREEN} ╚╝ ╩╩  ╚═╝╩╚═${CYAN}╚═╝╚═╝╩ ╩${RESET}"
    echo -e "${DIM}─────────────────────${RESET}"
    echo ""
    echo -e "${CYAN}>> First time setup${RESET}"
    echo ""

    # Find bin directories that are in PATH
    local bin_dirs=("$HOME/bin" "$HOME/.local/bin" "/usr/local/bin")
    local available_dirs=()

    for dir in "${bin_dirs[@]}"; do
        in_path "$dir" || continue
        if [[ -d "$dir" ]]; then
            available_dirs+=("$dir")
        else
            available_dirs+=("$dir (will create)")
        fi
    done

    if [[ ${#available_dirs[@]} -eq 0 ]]; then
        echo -e "${MAGENTA}>> No standard bin directories found in PATH${RESET}"
        echo -e "   Add ~/bin to your PATH and re-run with --setup"
        echo ""
        touch "$MARKER_FILE"
        return
    fi

    echo -e "   Create symlink to run viperssh from anywhere?"
    echo ""

    local i=1
    for dir in "${available_dirs[@]}"; do
        echo -e "   ${GREEN}[$i]${RESET} $dir"
        ((i++))
    done
    echo -e "   ${DIM}[s] Skip${RESET}"
    echo ""

    read -p "   >> Select directory: " choice

    if [[ "$choice" == "s" ]] || [[ "$choice" == "S" ]]; then
        echo -e "\n${DIM}>> Skipped. Run with --setup to configure later.${RESET}\n"
        touch "$MARKER_FILE"
        return
    fi

    if [[ "$choice" =~ ^[0-9]+$ ]] && [[ "$choice" -ge 1 ]] && [[ "$choice" -le ${#available_dirs[@]} ]]; then
        local selected="${available_dirs[$((choice-1))]}"
        # Remove "(will create)" suffix if present
        selected="${selected% (will create)}"

        # Create directory if needed
        if [[ ! -d "$selected" ]]; then
            mkdir -p "$selected"
            echo -e "\n${GREEN}>> Created $selected${RESET}"
        fi

        echo ""

        # Command name options
        local cmd_names=("viperssh" "viper" "vp")

        for cmd_name in "${cmd_names[@]}"; do
            echo -e "   Trying command name: ${CYAN}${cmd_name}${RESET}"
            if create_symlink "$selected" "$cmd_name"; then
                touch "$MARKER_FILE"
                echo -e "${DIM}Press Enter to launch ViperSSH...${RESET}"
                read -r
                return
            fi
        done

        # All default names failed, ask for custom name
        echo ""
        read -p "   >> Enter custom command name (or 's' to skip): " custom_name
        if [[ -n "$custom_name" ]] && [[ "$custom_name" != "s" ]]; then
            if create_symlink "$selected" "$custom_name"; then
                touch "$MARKER_FILE"
                echo -e "${DIM}Press Enter to launch ViperSSH...${RESET}"
                read -r
                return
            fi
        fi

        echo -e "\n${DIM}>> Symlink setup skipped.${RESET}\n"
    else
        echo -e "\n${DIM}>> Invalid selection, skipped.${RESET}\n"
    fi

    touch "$MARKER_FILE"
}

# Show help
if [[ "$1" == "--help" ]] || [[ "$1" == "-h" ]]; then
    echo "ViperSSH - TUI SSH Connection Manager"
    echo ""
    echo "Usage: viperssh [OPTIONS]"
    echo ""
    echo "Options:"
    echo "  --setup    Run first-time setup (symlink creation)"
    echo "  --check    Check system dependencies"
    echo "  -h, --help Show this help message"
    echo ""
    exit 0
fi

# Handle --check flag
if [[ "$1" == "--check" ]]; then
    check_dependencies
    echo -e "${GREEN}All required dependencies are installed.${RESET}"
    exit 0
fi

# Check required dependencies before creating venv
for dep in python3 ssh; do
    if ! command -v "$dep" &>/dev/null; then
        check_dependencies
    fi
done

# Check optional dependencies on first run
if [[ ! -f "$MARKER_FILE" ]]; then
    check_dependencies
fi

# Check if venv exists and has dependencies, if not create/fix it
if [[ ! -d "$VENV_DIR" ]] || ! "$VENV_DIR/bin/python3" -c "import textual" 2>/dev/null; then
    if [[ -d "$VENV_DIR" ]]; then
        echo -e "${CYAN}>> Reinstalling dependencies...${RESET}"
    else
        echo -e "${CYAN}>> Creating virtual environment...${RESET}"
        python3 -m venv "$VENV_DIR"
    fi
    echo -e "${CYAN}>> Installing dependencies...${RESET}"
    if ! "$VENV_DIR/bin/pip" install -r "$SCRIPT_DIR/requirements.txt"; then
        echo -e "${RED}>> Failed to install dependencies${RESET}"
        rm -rf "$VENV_DIR"
        exit 1
    fi
fi

# First-time setup prompt
if [[ ! -f "$MARKER_FILE" ]] || [[ "$1" == "--setup" ]]; then
    first_time_setup
    # Remove --setup from args if present
    [[ "$1" == "--setup" ]] && shift
fi

# Run viperssh with the venv python
exec "$VENV_DIR/bin/python3" "$SCRIPT_DIR/viper.py" "$@"
